#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
#include "images/garbage.h"
#include "images/winScreen.h"
#include "images/loseScreen.h"
#include "images/playa.h"
#include "images/background.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};

void initialize(struct rect *playerP, struct ball *bP, struct rect *redBrickLP, struct rect *redBrickRP, struct rect *orangeBrickLP,  struct rect *orangeBrickRP, struct rect *yellowBrickLP,  struct rect *yellowBrickRP, struct rect *greenBrickLP, struct rect *greenBrickRP, struct rect *blueBrickLP, struct rect *blueBrickRP, struct stats *statsP) {
  playerP->row = 140;
  playerP->col = 100;
  playerP->width = 60;
  playerP->height = 5;

  bP->row = 100;
  bP->col = 120;
  bP->size = 3;
  bP->velRow = -1;
  bP->velCol = -1;

  redBrickLP->row = 10;
  redBrickLP->col = 0;
  redBrickLP->width = 119;
  redBrickLP->height = 10;
  redBrickLP->is_alive = 1;

  redBrickRP->row = 10;
  redBrickRP->col = 121;
  redBrickRP->width = 119;
  redBrickRP->height = 10;
  redBrickRP->is_alive = 1;

  orangeBrickLP->row = 20;
  orangeBrickLP->col = 0;
  orangeBrickLP->width = 119;
  orangeBrickLP->height = 10;
  orangeBrickLP->is_alive = 1;

  orangeBrickRP->row = 20;
  orangeBrickRP->col = 121;
  orangeBrickRP->width = 119;
  orangeBrickRP->height = 10;
  orangeBrickRP->is_alive = 1;

  yellowBrickRP->row = 30;
  yellowBrickRP->col = 0;
  yellowBrickRP->width = 119;
  yellowBrickRP->height = 10;
  yellowBrickRP->is_alive = 1;

  yellowBrickLP->row = 30;
  yellowBrickLP->col = 121;
  yellowBrickLP->width = 119;
  yellowBrickLP->height = 10;
  yellowBrickLP->is_alive = 1;

  greenBrickLP->row = 40;
  greenBrickLP->col = 0;
  greenBrickLP->width = 119;
  greenBrickLP->height = 10;
  greenBrickLP->is_alive = 1;

  greenBrickRP->row = 40;
  greenBrickRP->col = 121;
  greenBrickRP->width = 119;
  greenBrickRP->height = 10;
  greenBrickRP->is_alive = 1;

  blueBrickLP->row = 50;
  blueBrickLP->col = 0;
  blueBrickLP->width = 119;
  blueBrickLP->height = 10;
  blueBrickLP->is_alive = 1;
  
  blueBrickRP->row = 50;
  blueBrickRP->col = 121;
  blueBrickRP->width = 119;
  blueBrickRP->height = 10;
  blueBrickRP->is_alive = 1;
  
  statsP->bricks = 10;
  statsP->lives = 3;
}

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  struct rect player;
  struct ball b;
  struct rect redBrickL;
  struct rect redBrickR;
  struct rect orangeBrickL;
  struct rect orangeBrickR;
  struct rect yellowBrickL;
  struct rect yellowBrickR;
  struct rect greenBrickL;
  struct rect greenBrickR;  
  struct rect blueBrickL;
  struct rect blueBrickR; 
  struct stats stats;

  initialize(&player, &b, &redBrickL, &redBrickR, &orangeBrickL, &orangeBrickR, &yellowBrickL, &yellowBrickR, &greenBrickL, &greenBrickR, &blueBrickL, &blueBrickR, &stats);
  int lives = stats.lives;
  int bricks = stats.bricks;

  enum gba_state state = START;
  drawFullScreenImageDMA(background);
  initialize(&player, &b, &redBrickL, &redBrickR, &orangeBrickL,  &orangeBrickR, &yellowBrickL, &yellowBrickR, &greenBrickL, &greenBrickR, &blueBrickL, &blueBrickR, &stats);
  lives = 3;
  bricks = 10;
  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();

    if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
      state = START;
      drawFullScreenImageDMA(background);
      initialize(&player, &b, &redBrickL, &redBrickR, &orangeBrickL, &orangeBrickR, &yellowBrickL, &yellowBrickR, &greenBrickL, &greenBrickR, &blueBrickL, &blueBrickR, &stats);
      lives = 3;
      bricks = 10;
    }

    switch (state) {
      case START:
        if(KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = PLAY;
          fillScreenDMA(BLACK);
          char freedom[] = "FREEDOM!!!";
          drawCenteredString(5, WIDTH / 2, 0, 0, freedom, WHITE);
          break;
        }
        char title[] = "CAT BREAKOUT";
        drawCenteredString(70, WIDTH / 2, 0, 0, title, WHITE);
        char startScreenText[] = "PRESS ENTER TO START";
        drawCenteredString(100, WIDTH / 2, 0, 0, startScreenText, WHITE);
        break;
      case PLAY:
        drawRectDMA(player.row, player.col, player.width, player.height, BLACK);
        drawRectDMA(b.row, b.col, b.size, b.size, BLACK);
        drawRectDMA(10, 0, WIDTH, 60, BLACK);

        char buffer[51];
        sprintf(buffer, "Lives: %d", lives);
        drawRectDMA(150, 5, 200, 10, BLACK);
        ///////////// UNDRAW ABOVE //////////////
        if (bricks == 0) {
          state = WIN;
          drawFullScreenImageDMA(winScreen);
          break;
        }

        if (lives == 0) {
          state = LOSE;
          drawFullScreenImageDMA(loseScreen);
          break;
        }

        if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
          if (player.col - 1 < 0) {
            player.col = 0;
          } else {
          player.col -= 1;
          }
        }

        if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
          if (player.col + player.width + 1 > WIDTH) {
            player.col = WIDTH - player.width;
          } else {
          player.col += 1;
          }
        }

        if (KEY_DOWN(BUTTON_UP, currentButtons)) {
          if (player.row - 1 < 0) {
            player.row = 0;
          } else if (player.row - 1 < 60) {
            player.row = 60;
          } else {
            player.row -= 1;
          }
        }

        if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
          if (player.row + player.height + 1 > HEIGHT) {
            player.row = HEIGHT - player.height;
          } else {
            player.row += 1;
          }
        }

        if (b.row + b.velRow < 0) {
          b.velRow *= -1;
        }

        if (b.row + b.velRow + b.size > HEIGHT) {
          lives--;
          b.velRow *= -1;
        }

        if (b.col + b.velCol < 0) {
          b.velCol *= -1;
        }

        if (b.col + b.velCol+ b.size > WIDTH) {
          b.velCol *= -1;
        }        

        if (rectCollision(player, b)) {
          b.velRow *= -1;
        }

        if (redBrickL.is_alive == 1) {
          if (rectCollision(redBrickL, b)) {
            redBrickL.is_alive = 0;
            bricks--;
            b.velRow *= -1;
          }
        }

        if (redBrickR.is_alive == 1) {
          if (rectCollision(redBrickR, b)) {
            redBrickR.is_alive = 0;
            bricks--;
            b.velRow *= -1;
          }
        }

        if (orangeBrickL.is_alive == 1) {
          if (rectCollision(orangeBrickL, b)) {
            orangeBrickL.is_alive = 0;
            bricks--;
            b.velRow *= -1;
          }
        }
        
        if (orangeBrickR.is_alive == 1) {
          if (rectCollision(orangeBrickR, b)) {
            orangeBrickR.is_alive = 0;
            bricks--;
            b.velRow *= -1;
          }
        }

        if (yellowBrickL.is_alive == 1) {
          if (rectCollision(yellowBrickL, b)) {
            yellowBrickL.is_alive = 0;
            bricks--;
            b.velRow *= -1;
          }
        }

        if (yellowBrickR.is_alive == 1) {
          if (rectCollision(yellowBrickR, b)) {
            yellowBrickR.is_alive = 0;
            bricks--;
            b.velRow *= -1;
          }
        }        

        if (greenBrickL.is_alive == 1) {
          if (rectCollision(greenBrickL, b)) {
            greenBrickL.is_alive = 0;
            bricks--;
            b.velRow *= -1;
          }
        }    
        
        if (greenBrickR.is_alive == 1) {
          if (rectCollision(greenBrickR, b)) {
            greenBrickR.is_alive = 0;
            bricks--;
            b.velRow *= -1;
          }
        } 

        if (blueBrickL.is_alive == 1) {
          if (rectCollision(blueBrickL, b)) {
            blueBrickL.is_alive = 0;
            bricks--;
            b.velRow *= -1;
          }
        }    

        if (blueBrickR.is_alive == 1) {
          if (rectCollision(blueBrickR, b)) {
            blueBrickR.is_alive = 0;
            bricks--;
            b.velRow *= -1;
          }
        }    

        b.row += b.velRow;
        b.col += b.velCol;

        //////////// DRAWING BELOW /////////////
        drawImageDMA(player.row, player.col, player.width, player.height, playa);
        drawImageDMA(b.row, b.col, b.size, b.size, garbage);
        if (redBrickL.is_alive == 1) {
          drawRectDMA(redBrickL.row, redBrickL.col, redBrickL.width, redBrickL.height, RED);        
        }
        if (redBrickR.is_alive == 1) {
          drawRectDMA(redBrickR.row, redBrickR.col, redBrickR.width, redBrickR.height, RED);        
        }
        if (orangeBrickL.is_alive == 1) {
          drawRectDMA(orangeBrickL.row, orangeBrickL.col, orangeBrickL.width, orangeBrickL.height, ORANGE);        
        }
        if (orangeBrickR.is_alive == 1) {
          drawRectDMA(orangeBrickR.row, orangeBrickR.col, orangeBrickR.width, orangeBrickR.height, ORANGE);        
        }
        if (yellowBrickL.is_alive == 1) {
          drawRectDMA(yellowBrickL.row, yellowBrickL.col, yellowBrickL.width, yellowBrickL.height, YELLOW);          
        }
        if (yellowBrickR.is_alive == 1) {
          drawRectDMA(yellowBrickR.row, yellowBrickR.col, yellowBrickR.width, yellowBrickR.height, YELLOW);          
        }
        if (greenBrickL.is_alive == 1) {
          drawRectDMA(greenBrickL.row, greenBrickL.col, greenBrickL.width, greenBrickL.height, GREEN);        
        }
        if (greenBrickR.is_alive == 1) {
          drawRectDMA(greenBrickR.row, greenBrickR.col, greenBrickR.width, greenBrickR.height, GREEN);        
        }
        if (blueBrickL.is_alive == 1) {
          drawRectDMA(blueBrickL.row, blueBrickL.col, blueBrickL.width, blueBrickL.height, BLUE);        
        }
        if (blueBrickR.is_alive == 1) {
          drawRectDMA(blueBrickR.row, blueBrickR.col, blueBrickR.width, blueBrickR.height, BLUE);        
        }
        drawString(150, 5, buffer, YELLOW);
        break;
      case WIN:
        // state = ?
        break;
      case LOSE:
        // state = ?
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}

int rectCollision(struct rect rect, struct ball b) {
  return 
    rect.col < b.col + b.size &&
    rect.col + rect.width > b.col &&
    rect.row < b.row + b.size &&
    rect.row + rect.height > b.row;
}